---
title: "DGE"
output: html_document
date: "2023-08-15"
---


```{r, setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

- based on DGE script from Ashley Weir 

## Data required:
- *20230815_STARcounts_TCGAOV.tsv* produced in temp_GDC_download_serverversion.Rmd 
 - meta data from TCGA download *20230815_clinical.csv*
- location on jblab server002: /home/lythgo02/ecotyper/20230720_TCGA_2nd_year/GDCdata/ 
- contrast labels *20230815_ST_58_Clinical_data_TCGA-OV_contrast_groups.tsv* produced in 20230725_TCGA_OV_stratification.Rmd 
- location on I-drive: ./Data/Processed/


```{r, message=FALSE, warning=FALSE}
setwd("/research/jblab/data/group_folders/emily_lythgoe/20230724_EcoTyper_2nd_year/")

library(dplyr)
library(tidyverse)
library(ggplot2)
library(stringr)
library(AnnotationDbi)
library(org.Hs.eg.db)
library(limma)
library(edgeR)
library(DESeq2)
library(janitor)
library(statmod)
```

**load data**

```{r, message=FALSE}

rawCounts <- read_delim("Y:/ecotyper/20230720_TCGA_2nd_year/GDCdata/20230815_STARcounts_TCGAOV.tsv", 
    delim = "\t", escape_double = FALSE, 
    trim_ws = TRUE)

meta <- read_csv("Y:/ecotyper/20230720_TCGA_2nd_year/GDCdata/20230815_clinical.csv") 

#need to check for the most recent version of the pan-cancer clinical data table (modified to contrast contrast labels in Rmd 20230725_TCGA_OV_stratification.Rmd on I drive
pancan_contrasts <-  read_delim("Data/Processed/20230815_ST_58_Clinical_data_TCGA-OV_contrast_groups.tsv", 
                        delim = "\t", escape_double = FALSE, trim_ws = TRUE) %>% 
                        dplyr::rename(submitter_id = name) %>%
                        mutate(submitter_id = str_trunc(submitter_id, 12, "right", ellipsis = "")) # some samples have additional letters at the end (unsure if this is vial number), remove these letters from name
```

**Wrangle data**
*Filter to include only primary samples. Note we have more than one sequencing file for some individuals eg TCGA-61-2008-01A.... and TCGA-61-2008-02A.... the 7-8th number in the sequence indicates the sample type, 01 is a primary tumour and 02 is a recurring tumour (see GDC sample type codes)*

```{r wrangle data}

# make ID column rownames
rawCounts <- rawCounts %>% 
  column_to_rownames(var = "gene_id") #430 cases with RNAseq counts from GDC
rawCounts <- rawCounts %>% 
  dplyr::select(-matches("02A|TCGA-23-1023-01R")) # remove any secondary samples and TCGA-23-1023-01R (have TCGA-23-1023-01A in addition which I have kept)

#the gene names are already present within the rawCounts data - use the annotation package instead as this is more reliable for matching the symbols

primary_samples <- as.data.frame(colnames(rawCounts)) %>% 
   str_trunc(16, "right", ellipsis = "") %>% 
  clean_names() %>% 
  dplyr::rename(submitter_id = colnames_raw_counts) %>% 
  str_trunc(12, "right", ellipsis = "") 
  
#filtered_pancan <- left_join(primary_samples, pancan_contrasts) 

# pull out cases not present in the pancancer table
#cases_missing_labels <- filtered_pancan %>% 
 # filter(is.na(cx3)) %>% 
 # dplyr::select(submitter_id) %>% 
 # write_delim("./Data/Processed/20230815_rnaseq_cases_missing_from_pancan.tsv", delim = "\t")

```

```{r, message=FALSE}
#reload the cases_missing_labels list annotated using Wang 2017 and Takaya 2020 annotation
cases_missing_labels <- read_csv("Data/Processed/20230815_rnaseq_cases_missing_from_pancan.csv")

pancan_contrasts_shortened <- pancan_contrasts %>% 
  dplyr::select("submitter_id", "contrast_group") #only need the contrast info for now
 
meta_plus_contrast <- cases_missing_labels %>% 
  dplyr::select("submitter_id", "contrast_group") %>% 
  full_join(meta)

# add in the contrast group info from cases_missing_labels into meta_plus_contrast group

meta_plus_contrast <- meta_plus_contrast %>%  
  left_join(pancan_contrasts_shortened, by = ("submitter_id")) %>%  
  mutate(contrast_group = if_else(is.na(contrast_group.y), contrast_group.x, contrast_group.y)) %>% 
  dplyr::select(-contrast_group.x, -contrast_group.y) 
#mutate line: the left_join merges the two tables by ID but keeps both contrast columns (renamed as contrast_group.y and contrast_group.x). The mutate creates a new column contrast_group, checks for NA in the contrast_group.y column and enters the value of the contrast_group.x column in the new contrast_group column if it is NA, otherwise it enters the value in the conrast_group.y column. 

#note if using if_else() from dplyr, use | and & as comparison operators, but if using if and else from base r, use || and && as comparison operators

 tabyl(meta_plus_contrast$contrast_group)
```
**matching primary samples in rawcounts to samples in meta data**
```{r}
meta_rawCounts_matched <- meta_plus_contrast[meta_plus_contrast$submitter_id %in% primary_samples$submitter_id,]

merged_data <- primary_samples %>%
  left_join(meta_rawCounts_matched, by = c("submitter_id" = "submitter_id"))

# Arrange the rows based on the order of submitter_id in primary_samples
meta_rawCounts_matched <- merged_data %>%
  arrange(match(submitter_id, primary_samples$submitter_id)) # Now ordered_data contains the rows from meta_rawCounts_matched in the same order as in primary_samples

colnames(rawCounts) <- substr(colnames(rawCounts), 1, 12)

missing_contrast <- meta_rawCounts_matched[is.na(meta_rawCounts_matched$contrast_group),]

rawCounts_final <- rawCounts[,!colnames(rawCounts) %in% missing_contrast$submitter_id] 
 rawCounts_final <- cbind(rawCounts$gene_name, rawCounts_final) %>% 
 dplyr::rename(gene_name = "rawCounts$gene_name")

meta_rawCounts_matched <- meta_rawCounts_matched[!is.na(meta_rawCounts_matched$contrast_group),]
```

**Annotate genes - not necessary if using gene_names present in rawCounts data.**

```{r geneAnnotation}
columns(org.Hs.eg.db)
colGene <- c("ENTREZID", "SYMBOL", "GENETYPE", "ENSEMBL") #defines the columns you want to select from the gene annotation database
ensembl <- data.frame(ensembl_id = rownames(rawCounts_final)) %>% 
  separate(ensembl_id, into = c("ensembl_id", "version_number"), sep="\\.") 
#ensembl_id <- as.character(ensembl$ensembl_id)
geneIdMap <- AnnotationDbi::select(org.Hs.eg.db, #the org.Hs.eg.db package provides annotations for the human genome
                                       keys = as.character(ensembl$ensembl_id), 
                                       columns = colGene, keytype = "ENSEMBL") #queries the org.Hs.eg.db gene annotation database using the Ensembl Gene IDs as keys. It retrieves the specified columns (colGene) for the provided gene IDs (gene_id) using the specified key type (ENSEMBL).

#count(is.na(geneIdMap$ENTREZID)) # 24622 don't match to an ID
#duplicated_geneIdMap <- geneIdMap %>% 
  #filter(duplicated(ENTREZID) &!is.na(ENTREZID)) #2812 duplicated ID

geneIdMap <- geneIdMap[!duplicated(geneIdMap$ENTREZID), ]#remove duplicated rows from the geneIdMapExAn data frame based on the ENTREZID (retaining one copy of each duplicate)
geneIdMap <- geneIdMap[complete.cases(geneIdMap), ] # one gene has missing entries, remove

rawCounts_final <- rawCounts[geneIdMap$ENSEMBL, ]
rawCounts_final <- rawCounts_final[,!colnames(rawCounts) %in% missing_contrast$submitter_id]
rawCounts_final <- rawCounts_final[complete.cases(rawCounts_final), ]

ensembl <- data.frame(ensembl_id = rownames(rawCounts_final)) %>% 
  separate(ensembl_id, into = c("ensembl_id", "version_number"), sep="\\.") #regenerate filtered list of ENSEMBL to filter geneIdMap by
geneIdMap <- geneIdMap[geneIdMap$ENSEMBL %in% ensembl$ensembl_id, ] #filter to remove rows no longer present in rawCounts_final


#(question for Ash, is it normal to go from 60660 to 36639 rows of gene expression data after gene annotation?)

```
**Create rawCounts_final in EcoTyper format**

```{r}

EcoTyper_counts <- rawCounts_final %>%
  rownames_to_column("gene_id") %>%  
  separate(gene_id, into = c("ENSEMBL", "version_number"), sep = "\\." ) %>% 
  group_by(ENSEMBL) %>% 
  summarize(across(where(is.numeric), median)) #collapse transcript variants into median value for that ENSEMBL ID as separating version numbers from ENSEMBL creates duplicates 

EcoTyper_final <- EcoTyper_counts %>% 
  inner_join(geneIdMap %>% dplyr::select(ENSEMBL, SYMBOL), by = "ENSEMBL")# %>% 
 #save <- EcoTyper_final %>%  dplyr::select(-ENSEMBL) %>% write_delim("./Data/Processed/20230908_EcoTyperCountsMappedMedian.tsv", delim="\t")

```


**Create a DGE object for DE analysis.**
#NOTE need to delete the first DGEList object and run the two below if I am creating two separate DGEList objects for each contrast
```{r dgeObject}

dge <- DGEList(counts = rawCounts_final, genes = geneIdMap, samples = meta_rawCounts_matched, group = meta_rawCounts_matched$contrast_group) # contains all samples in one object 

```

**Create rawCounts_final in EcoTyper format**

```{r}

EcoTyper_counts <- as.data.frame(dgeFilExp$counts) %>%
  rownames_to_column("gene_id") %>%  
  separate(gene_id, into = c("ENSEMBL", "version_number"), sep = "\\." ) %>% 
   group_by(ENSEMBL) %>% 
  summarize(across(where(is.numeric), median))
 # Remove duplicates from geneIdMap
 geneIdMap_unique <- distinct(geneIdMap, ENSEMBL, .keep_all = TRUE)

EcoTyper_final <- as.data.frame(EcoTyper_counts) %>% 
  inner_join(geneIdMap_unique %>% dplyr::select(ENSEMBL, SYMBOL), by = "ENSEMBL")# %>% 
 EcoTyper_final %>%  dplyr::select(-ENSEMBL) %>% write_delim("./Data/Processed/20230908_EcoTyperCountsMappedMedian.tsv", delim="\t")

```

**Filter lowly expressed genes.**
*Using manual filtering and the filterByExp() function*

```{r }
# filter lowly expressed genes
cutoff <- 4
drop <- which(apply(cpm(dge), 1, max) < cutoff) #cpm() calculates counts per million for normalisation, apply() is then used to calculate the max (using max()) CPM value across all rows (1 means all rows, 2 would mean all columns), and which() returns indices of genes where max cpm < 4
dgeFil <- dge[-drop, , keep.lib.sizes = FALSE] 
dim(dgeFil) # number of genes left after manual filtering

keep <- filterByExpr(dgeFil, group = dgeFil$samples$contrast_group) #filters genes with low counts 

dgeFilExp <- dgeFil[keep, ,keep.lib.sizes = FALSE ] 
dim(dgeFilExp) # number of genes left after manual filtering and filterByExpr

```

**process all contrast groups together for now **
```{r}
#check for samples that have more counts on average than other samples 
boxplot(log(dgeFilExp$counts + 0.5), xaxt = "n", col = "turquoise4", xlab = "Samples") # look at raw log counts (+0.5 to prevent taking the log of 0)
boxplot(cpm(dgeFilExp$counts, log = TRUE), xaxt = "n", col = "turquoise4", xlab = "Samples") # look at log cpm normalised counts

plotSparsity(dgeFilExp$counts, normalized = TRUE) # normalised to account for variations in library size  to avoid sequencing bias


```

**Normalisation.**

```{r}

# calculate normalisation factors (does not normalise)
dgeFilExpNorm <- calcNormFactors(dgeFilExp)

barplot(dgeFilExpNorm$samples$norm.factors, las = 2)
title("Barplot of normalisation factors")

```

**Define group for contrast interactions**
```{r}

 
group <-  interaction(dgeFilExpNorm$samples$contrast_group)
groupCol <- group # you could just use the original interaction vector, but I like to make a new one that I will overlay colours on.
levels(groupCol) <- c("#F8766D", "#00BFC4", "#00BA38") # change levels to colour names/HEX codes.
# BRCA1/2 Loss == turquoise (#00BFC4)
#HRD high == tomato ("#F8766D")
#HRD low == green ("#00BA38")
groupCol <- as.character(groupCol) # make sure R knows the colour replacements are characters.

plotMDS(dgeFilExpNorm, col = groupCol, labels = NULL, pch = 20) #multidimensional scaling plot to visualise similarity between samples based on gene expression profiles 
legend("topright", legend = c("BRCA1/2 loss", "HRD high", "HRD low"), fill =  c("#F8766D", "#00BFC4", "#00BA38"))
#distances on the plot approximate the typical log2 fold changes between the samples 

```
**defining covariate interactions**
#NOTE NEED to collapse the stages into 1-4, the separation may be too granular to see any possible confounders at present 
```{r}

stage <- interaction(dgeFilExpNorm$samples$figo_stage)
# Levels: Stage IC, IIA, IIB, IIC, IIIA, IIIB, IIIC, IV
levels(stage) <- c("darkorange", "cornflowerblue", "darkolivegreen3", "deeppink3", "darkorchid", "brown1", "darkgrey", "chartreuse" ) 
stage <- as.character(stage) 

plotMDS(dgeFilExpNorm, col = stage, labels = NULL, pch = 20)
legend("topright", legend = c("Stage IC", "IIA", "IIB", "IIC", "IIIA", "IIIB", "IIIC", "IV"), fill =  c("darkorange", "cornflowerblue", "darkolivegreen3", "deeppink3", "darkorchid", "brown1", "darkgrey", "chartreuse" ) )


```
```{r}

age_at_diagnosis <- interaction(dgeFilExpNorm$samples$age_at_diagnosis)

plotMDS(dgeFilExpNorm, col = age_at_diagnosis, labels = NULL, pch = 20)

```
```{r}

site <- interaction(dgeFilExpNorm$samples$site_of_resection_or_biopsy)

plotMDS(dgeFilExpNorm, col = site, labels = NULL, pch = 20)

```
These MDS plots are *extremely* important. They show what most of your variation comes from. These covariates need to be included in our design matrix, since we are primarily interested in BRCA1/2 and HRD status.


**Define the design matrix.**

```{r}

# specify the model to be fitted
modelMatrix <- model.matrix(~ 0 + group , data=dgeFilExpNorm) # specifies the design of the linear model
# currently not adjusting for any additional covariates
```

**Voom transformation.** 

```{r}

# voom transformation
voom <- voom(dgeFilExpNorm, modelMatrix, plot = TRUE) #voom transformation transforms counts to log2 CPM based on the normalisation factors calculated earlier. It also fits a linear model to the log2 CPM for each gene (row-wise), calculates the residuals, and then fits a smoothed curve to the square root of the residual standard deviation by average expression. The smoothed curve is used to obtain weights for each gene and sample, which are then passed into limma for DEA taking into account the variability of each gene.

# look at diagnostic plots
plotMDS(dgeFilExpNorm, col = groupCol, labels = NULL, pch = 20)
legend("topright", legend = c("BRCA1/2 loss", "HRD high", "HRD low"), fill =  c("#F8766D", "#00BFC4", "#00BA38"))

```


**Fit linear model.**

```{r}
# fitting a linear model using weighted least squares for each gene
fit <- lmFit(voom, modelMatrix) # now run DEA
head(coef(fit)) #display the coefficients for the model terms defined in the model matrix. These coefficients will be used to perform hypothesis testing to determine significantly up/down regulated genes. 

```
**Define contrast.**

```{r}
# comparison between groups (log-fold changes) are obtained as contrasts of these fitted linear models
contr <- makeContrasts( groupHRD_high - groupBRCA1_2_loss, groupHRD_low - groupBRCA1_2_loss, levels = modelMatrix) # define the comparisons you want to make
#  groupHRD_high - groupBRCA1_2_loss, # Coefficient 1
 # groupHRD_low - groupBRCA1_2_loss,  # Coefficient 2
contr
contrastsfit <- contrasts.fit(fit, contrasts = contr) # fit the contrasts to the linear model fit and calculate the coefficients 
fittedContrasts <- eBayes(contrastsfit, robust = TRUE) # use robust emperical bayes for statitsical testing to account for potnetial issues with heteroscedasticy (varying levels of dispersion) in the data. Helps to obtain more accurate p-values and effect size estimates.

```
**Extract to contrasts.**
```{r}

results_HRDhigh <- topTable(fittedContrasts, coef= "groupHRD_high - groupBRCA1_2_loss", sort.by = "P", n = Inf) # lists the top DE genes 
head(results_HRDhigh, 20) # generate a table of top 20 DE genes (sorted by p value), n=Inf means retreive all DE genes (no limit on number)
#write_csv(results_HRDhigh, "I:/research/jblab/data/group_folders/emily_lythgoe/20230724_EcoTyper_2nd_year/Output/Data/20230905_topTableDEgenes_BRCA1_2_loss_vs_HRD_high.csv")

results_HRDlow <- topTable(fittedContrasts, coef= "groupHRD_low - groupBRCA1_2_loss", sort.by = "P", n = Inf)
head(results_HRDlow, 20)
#write_csv(results_HRDlow, "I:/research/jblab/data/group_folders/emily_lythgoe/20230724_EcoTyper_2nd_year/Output/Data/20230905_topTableDEgenes_BRCA1_2_loss_vs_HRD_low.csv")
```
**Statistical testing.**
*The output from topTable() includes*
*logFC: the log fold-change between cases and controls.*
*t: the t-statistic used to assess differential expression.*
*P.Value: the p-value for differential expression; this value is not adjusted for multiple testing.*
*adj.P.Val: the p-value adjusted for multiple testing. Different adjustment methods are available, the default is Benjamini-Horchberg.*

*Just looking at BRCA1/2 vs HRD low*
```{r}

# Total number of DE genes based on adjusted p value < 0.05
length(which(results_HRDlow$adj.P.Val < 0.05))

# Total number of DE genes based on adjusted p value < 0.05 and |logFC| (absolute log fold-change) >= 1.0
length(which(results_HRDlow$adj.P.Val < 0.05 & abs(results_HRDlow$logFC) >= 1.0 ))

# Total number of DE genes based on adjusted p value < 0.01 and |logFC| >= 1.0
length(which(results_HRDlow$adj.P.Val < 0.01 & abs(results_HRDlow$logFC) >= 1.0 ))

dt <- decideTests(fittedContrasts, p.value = 0.05, lfc = 1.0) #makes DE gene calls based on a specified p-value and log-fold change threshold 
summary(dt)

```


**Plots for DE contrast: BRCA1/2 loss vs HRD low**
*you should be able to provide the gene names from fittedContrasts but I don't seem to have them, check why this is*
```{r}
volcanoplot(
  fittedContrasts,             # The fitted contrasts object
  coef = "groupHRD_low - groupBRCA1_2_loss",                    # Specify the contrast (coefficient) you want to visualize
  highlight = 10,               # The number of top genes to highlight (you can adjust this)
  names = fittedContrasts$genes$SYMBOL,    # The gene symbols (replace 'genes$SYMBOL' with the actual gene symbol data)
  main = "Volcano Plot"        # Title for the plot (replace with your desired title)
)

#x axis - upregulation (positive values) and downregulation (negative) of genes 
#y-axis - statistical significance 
#each gene = a dot

limma::plotMA(fittedContrasts, coef = "groupHRD_low - groupBRCA1_2_loss", status = dt[ ,"groupHRD_low - groupBRCA1_2_loss"], hl.pch = 20, bg.col = "grey") #MA plot displays log-fold change against the average log expression for each gene 
o <- order(fittedContrasts$p.value[,"groupHRD_low - groupBRCA1_2_loss"]) # orders the genes based on their p-value from DEA
x <- fittedContrasts$Amean #extracts the average log-expression values (Amean) for all genes 
y <- fittedContrasts$coefficients[,"groupHRD_low - groupBRCA1_2_loss"] #extracts the log fold change values (coefficients) for the contrast group 
G <- fittedContrasts$genes$SYMBOL #extracts the gene names for genes in the fittedContrasts objects 
text(x[o[1:10]], y[o[1:10]],labels = G[o[1:10]], 
     cex = 0.7,  # Adjust the label size (0.7 means 70% of the default size)
     col = "black",  # Change label color to blue
     srt = 45) # to show the top 6 DE gene symbols



```

**Gene ontology analyiss with Goana.**
*end up with 0 for ENTREZID*

```{r}
# subset DE genes to include those of great significance and large-ish logFC
genesDE_HRDhigh <- results_HRDhigh %>%
  mutate(bigLogFC = case_when(logFC < -1.0 | logFC > 1.0 ~ "keep",
                              TRUE ~ "discard")) %>% 
  dplyr::filter(bigLogFC == "keep") %>% 
  dplyr::filter(adj.P.Val < 0.05) %>% 
  dplyr::select(ENTREZID) 
genesDE_HRDhigh <- as.vector(genesDE_HRDhigh)  

## gene ontology
gene_ont <- goana(genesDE_HRDhigh)
 topGO(gene_ont)

gene_ont$adj.P.Val <- p.adjust(gene_ont$P.ENTREZID, method="BH")

gene_ont <- gene_ont %>% 
  rownames_to_column(var = "goTerm")

#write_csv(gene_ont, "TCGA_DGE_geneOntology_ELythgoe_20230906.csv")

```

