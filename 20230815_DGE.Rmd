---
title: "DGE"
output: html_document
date: "2023-08-15"
---


```{r, setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

- based on DGE script from Ashley Weir 

## Data required:
- *20230815_STARcounts_TCGAOV.tsv* produced in temp_GDC_download_serverversion.Rmd 
 - meta data from TCGA download *20230815_clinical.csv*
- location on jblab server002: /home/lythgo02/ecotyper/20230720_TCGA_2nd_year/GDCdata/ 
- contrast labels *20230815_ST_58_Clinical_data_TCGA-OV_contrast_groups.tsv* produced in 20230725_TCGA_OV_stratification.Rmd 
- location on I-drive: ./Data/Processed/


```{r, message=FALSE, warning=FALSE}
setwd("/research/jblab/data/group_folders/emily_lythgoe/20230724_EcoTyper_2nd_year/")

library(dplyr)
library(tidyverse)
library(ggplot2)
library(stringr)
library(AnnotationDbi)
library(org.Hs.eg.db)
library(limma)
library(edgeR)
library(DESeq2)
library(janitor)
```

**load data**

```{r, message=FALSE}

rawCounts <- read_delim("Y:/ecotyper/20230720_TCGA_2nd_year/GDCdata/20230815_STARcounts_TCGAOV.tsv", 
    delim = "\t", escape_double = FALSE, 
    trim_ws = TRUE)

meta <- read_csv("Y:/ecotyper/20230720_TCGA_2nd_year/GDCdata/20230815_clinical.csv")

#need to check for the most recent version of the pan-cancer clinical data table (modified to contrast contrast labels in Rmd 20230725_TCGA_OV_stratification.Rmd on I drive
pancan_contrasts <-  read_delim("Data/Processed/20230815_ST_58_Clinical_data_TCGA-OV_contrast_groups.tsv", 
                        delim = "\t", escape_double = FALSE, trim_ws = TRUE) %>% 
                        dplyr::rename(submitter_id = name) %>%
                        mutate(submitter_id = str_trunc(submitter_id, 12, "right", ellipsis = "")) # some samples have additional letters at the end (unsure if this is vial number), remove these letters from name
```

**Wrangle data**

```{r wrangle data}

# make ID column rownames
rawCounts <- rawCounts %>% 
  column_to_rownames(var = "gene_id") #430 cases with RNAseq counts from GDC

#the gene names are already present within the rawCounts data 
annotated_genes <- data.frame(rawCounts$gene_name) 
annotated_genes <- data.frame(rownames(rawCounts), annotated_genes) # Create a new data frame with row names and the gene_name column
colnames(annotated_genes) <- c("ensembl_id", "gene_name") # Rename the columns for clarity

rawCounts <- rawCounts %>% 
  dplyr::select(-"gene_name")
#get list of IDs you need the metadata for (all those with RNAseq counts)
#note we have more than one sequencing file for some individuals eg TCGA-61-2008-01A.... and TCGA-61-2008-02A.... the 7-8th number in the sequence indicates the sample type, 01 is a primary tumour and 02 is a recurring tumour (see GDC sample type codes)
#filter to include only primary tumours
primary_samples <- as.data.frame(colnames(rawCounts)) %>% 
   str_trunc(16, "right", ellipsis = "") %>% 
  clean_names() %>% 
  dplyr::rename(submitter_id = colnames_raw_counts) %>% 
  filter(!str_detect(submitter_id,"02A") & !str_detect(submitter_id,"01R")) %>% # TCGA-23-1023 is present twice as TCGA-23-1023-01A and TCGA-23-1023-01R, I have removed 01R for now
  str_trunc(12, "right", ellipsis = "") 
  
rawCounts <- rawCounts %>% 
  dplyr::select(-matches("02A|TCGA-23-1023-01R")) # remove any secondary samples and TCGA-23-1023-01R

#filtered_pancan <- left_join(primary_samples, pancan_contrasts) 

# pull out cases not present in the pancancer table
#cases_missing_labels <- filtered_pancan %>% 
 # filter(is.na(cx3)) %>% 
 # dplyr::select(submitter_id) %>% 
 # write_delim("./Data/Processed/20230815_rnaseq_cases_missing_from_pancan.tsv", delim = "\t")

```

```{r, message=FALSE}
#reload the cases_missing_labels list annotated using Wang 2017 and Takaya 2020 annotation
cases_missing_labels <- read_csv("Data/Processed/20230815_rnaseq_cases_missing_from_pancan.csv")

pancan_contrasts_shortened <- pancan_contrasts %>% 
  dplyr::select("submitter_id", "contrast_group") #only need the contrast info for now
 
meta_plus_contrast <- cases_missing_labels %>% 
  dplyr::select("submitter_id", "contrast_group") %>% 
  full_join(meta)

# add in the contrast group info from cases_missing_labels into meta_plus_contrast group

meta_plus_contrast <- meta_plus_contrast %>%  
  left_join(pancan_contrasts_shortened, by = ("submitter_id")) %>%  
  mutate(contrast_group = if_else(is.na(contrast_group.y), contrast_group.x, contrast_group.y)) %>% 
  dplyr::select(-contrast_group.x, -contrast_group.y)
#mutate line: the left_join merges the two tables by ID but keeps both contrast columns (renamed as contrast_group.y and contrast_group.x). The mutate creates a new column contrast_group, checks for NA in the contrast_group.y column and enters the value of the contrast_group.x column in the new contrast_group column if it is NA, otherwise it enters the value in the conrast_group.y column. 

#note if using if_else() from dplyr, use | and & as comparison operators, but if using if and else from base r, use || and && as comparison operators

 tabyl(meta_plus_contrast$contrast_group)
```
**matching primary samples in rawcounts to samples in meta data**
```{r}
meta_rawCounts_matched <- meta_plus_contrast[meta_plus_contrast$submitter_id %in% primary_samples$submitter_id,]

merged_data <- primary_samples %>%
  left_join(meta_rawCounts_matched, by = c("submitter_id" = "submitter_id"))

# Arrange the rows based on the order of submitter_id in primary_samples
meta_rawCounts_matched <- merged_data %>%
  arrange(match(submitter_id, primary_samples$submitter_id)) # Now ordered_data contains the rows from meta_rawCounts_matched in the same order as in primary_samples

colnames(rawCounts) <- substr(colnames(rawCounts), 1, 12)
```

**split into my two contrast: BRCA1/2 loss vs HRD high and BRCA1/2 loss vs HRD low**
```{r}

meta_rawCounts_matched_1 <- meta_rawCounts_matched %>% filter(contrast_group == "BRCA1/2_loss" | contrast_group == "HRD_high")
meta_rawCounts_matched_2 <- meta_rawCounts_matched %>% filter(contrast_group == "BRCA1/2_loss" | contrast_group == "HRD_low")

rawCounts_1 <- rawCounts[,colnames(rawCounts) %in% meta_rawCounts_matched_1$submitter_id]
rawCounts_2 <- rawCounts[,colnames(rawCounts) %in% meta_rawCounts_matched_2$submitter_id]
```
**Create a DGE object for DE analysis.**

```{r dgeObject}

dge_1 <- DGEList(counts = rawCounts_1, genes = annotated_genes$ensembl_id, samples = meta_rawCounts_matched_1, group = meta_rawCounts_matched_1$contrast_group) 
dge_2 <- DGEList(counts = rawCounts_2, genes = annotated_genes$ensembl_id, samples = meta_rawCounts_matched_2, group = meta_rawCounts_matched_2$contrast_group)
 
```


**Filter lowly expressed genes.**
*Using manual filtering and the filterByExp() function*

```{r dge_1 BRCA1/2 loss vs HRD high}
# filter lowly expressed genes
cutoff <- 4
drop_1 <- which(apply(cpm(dge_1), 1, max) < cutoff)
dgeFil_1 <- dge_1[-drop, , keep.lib.sizes = FALSE] 
dim(dgeFil_1) # number of genes left after manual filtering

keep <- filterByExpr(dgeFil_1, group = dgeFil_1$samples$contrast_group)

dgeFilExp_1 <- dgeFil_1[keep, ,keep.lib.sizes = FALSE ]
dim(dgeFilExp_1) # number of genes left after manual filtering and filterByExpr

```

```{r dge_2 BRCA1/2 loss vs HRD low}
# filter lowly expressed genes
cutoff <- 4
drop_2 <- which(apply(cpm(dge_2), 1, max) < cutoff)
dgeFil_2 <- dge_2[-drop, , keep.lib.sizes = FALSE] 
dim(dgeFil_2) # number of genes left after manual filtering

keep <- filterByExpr(dgeFil_2, group = dgeFil_2$samples$contrast_group)

dgeFilExp_2 <- dgeFil_2[keep, ,keep.lib.sizes = FALSE ]
dim(dgeFilExp_2) # number of genes left after manual filtering and filterByExpr

```

```{r}

boxplot(log(dgeFilExp_1$counts + 0.5), xaxt = "n", col = "turquoise4", xlab = "Samples") # look at raw log counts
boxplot(cpm(dgeFilExp_1$counts, log = TRUE), xaxt = "n", col = "turquoise4", xlab = "Samples") # look at log cpm normalised counts

plotSparsity(dgeFilExp_1$counts, normalized = TRUE)

```

**Normalisation.**

```{r deg_1}

# calculate normalisation factors (does not normalise)
dgeFilExpNorm_1 <- calcNormFactors(dgeFilExp_1)

barplot(dgeFilExpNorm_1$samples$norm.factors, names = colnames(dgeFilExpNorm_1), las = 2)
title("Barplot of normalisation factors")

```
 
**Contrast: dge_1 BRCA1/2 loss vs HRD high.**
*Define group for contrast and covariate interactions*
check if I need to run DGE for the two contrast groups separately or if I can run them together and separate out at this stage
```{r}

 
group_1 <-  interaction(dgeFilExpNorm_1$samples$contrast_group)
groupCol_1 <- group_1 # you could just use the original interaction vector, but I like to make a new one that I will overlay colours on.
levels(groupCol_1) <- c("#F8766D", "#00BFC4") # change levels to colour names/HEX codes.
# untreated == turquoise (#00BFC4)
# auranofin == tomato ("#F8766D")
groupCol_1 <- as.character(groupCol_1) # make sure R knows the colour replacements are characters.

plotMDS(dgeFilExpNorm_1, col = groupCol_1, labels = NULL, pch = 20)
legend("topright", legend = c("BRCA1/2 Loss", "HRD high"), fill =  c("#F8766D", "#00BFC4"))

```



**redundant**
**steps which were required before running DGEList**

**Annotate genes - not necessary if using gene_names present in rawCounts data.**

```{r geneAnnotation}
 # Human Ensembl/GENCODE gene accession numbers start with ENSG followed by a number and version number separated by a dot. 
ensembl <- data.frame(ensembl_id = rownames(rawCounts)) %>%  #create a data frame with a column for row names
  separate(ensembl_id, into = c("ensembl_id", "version_number"), sep="\\.")  #escape the dot in sep argument using \\. because the dot is a special character

ensembl_id <- as.character(ensembl$ensembl_id) # don't need version number for now, keys must be provided as character 


colGene <- c("ENTREZID", "SYMBOL", "GENETYPE", "ENSEMBL") #defines the columns you want to select from the gene annotation database

geneIdMap <- AnnotationDbi::select(org.Hs.eg.db, #the org.Hs.eg.db package provides annotations for the human genome
                                       keys = ensembl_id, 
                                       columns = colGene, keytype = "ENSEMBL") #queries the org.Hs.eg.db gene annotation database using the Ensembl Gene IDs as keys. It retrieves the specified columns (colGene) for the provided gene IDs (gene_id) using the specified key type (ENSEMBL).

count(is.na(geneIdMap$ENTREZID)) # 24622 don't match to an ID
duplicated_geneIdMap <- geneIdMap %>% 
  filter(duplicated(ENTREZID) &!is.na(ENTREZID)) #2812 duplicated ID

#remove duplicated rows from the geneIdMapExAn data frame based on the ENTREZID column (retaining one copy of any duplicated name)
geneIdMap <- geneIdMap[!duplicated(geneIdMap$ENTREZID), ]

geneIdMap <- geneIdMap[geneIdMap$ENSEMBL %in% ensembl_id, ] 
geneIdMap <- geneIdMap[complete.cases(geneIdMap), ] # one gene has missing entries, remove

genes <-  geneIdMap$ENSEMBL

#(question for Ash, is it normal to go from 60660 to 36639 rows of gene expression data after gene annotation?)

```


**Create matrix of read counts.**

```{r}

rawCountsCleaned <- as.matrix(rawCounts[genes, ]) %>% # filters the raw count data for genes that match the annotated expression data and converts to a matrix 
  apply( 2, function(x) as.numeric(trimws(x))) 
rownames(rawCountsCleaned) <- rownames(rawCounts[genes, ])

#apply(...) applies the function that removes leading spaces and converts values to numeric for each column of the filtered and converted matrix....
   #apply is used to apply a function to each column (indicated by '2')
   #the function is an anonymous function created using function(x) - Inside the function: trimws(x): removes leading and trailing white spaces from the character values in column x which are then converted to numbers.
count(is.na(meta_rawCounts_matched$contrast_group)) #DGEList can't accept NA values

 meta_rawCounts_matched <- meta_rawCounts_matched %>% 
  mutate(contrast_group = if_else(is.na(contrast_group), "unknown", contrast_group)) #if NA in contrast_group, replace with "unknown", otherwise keep contrast_group entry


dge <- DGEList(counts = rawCountsCleaned, genes = geneIdMap_clean$ENTREZID, samples = meta_rawCounts_matched, group = meta_rawCounts_matched$contrast_group) 

```

