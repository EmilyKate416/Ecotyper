---
title: "DGE"
output: html_document
date: "2023-08-15"
---


```{r, setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

- based on DGE script from Ashley Weir 

## Data required:
- *20230815_STARcounts_TCGAOV.tsv* produced in temp_GDC_download_serverversion.Rmd 
 - meta data from TCGA download *20230815_clinical.csv*
- location on jblab server002: /home/lythgo02/ecotyper/20230720_TCGA_2nd_year/GDCdata/ 
- contrast labels *20230815_ST_58_Clinical_data_TCGA-OV_contrast_groups.tsv* produced in 20230725_TCGA_OV_stratification.Rmd 
- location on I-drive: ./Data/Processed/


```{r, message=FALSE, warning=FALSE}
setwd("/research/jblab/data/group_folders/emily_lythgoe/20230724_EcoTyper_2nd_year/")

library(dplyr)
library(tidyverse)
library(ggplot2)
library(stringr)
library(AnnotationDbi)
library(org.Hs.eg.db)
library(limma)
library(edgeR)
library(DESeq2)
library(janitor)
```

**load data**

```{r, message=FALSE}

rawCounts <- read_delim("Y:/ecotyper/20230720_TCGA_2nd_year/GDCdata/20230815_STARcounts_TCGAOV.tsv", 
    delim = "\t", escape_double = FALSE, 
    trim_ws = TRUE)

meta <- read_csv("Y:/ecotyper/20230720_TCGA_2nd_year/GDCdata/20230815_clinical.csv") 

#need to check for the most recent version of the pan-cancer clinical data table (modified to contrast contrast labels in Rmd 20230725_TCGA_OV_stratification.Rmd on I drive
pancan_contrasts <-  read_delim("Data/Processed/20230815_ST_58_Clinical_data_TCGA-OV_contrast_groups.tsv", 
                        delim = "\t", escape_double = FALSE, trim_ws = TRUE) %>% 
                        dplyr::rename(submitter_id = name) %>%
                        mutate(submitter_id = str_trunc(submitter_id, 12, "right", ellipsis = "")) # some samples have additional letters at the end (unsure if this is vial number), remove these letters from name
```

**Wrangle data**

```{r wrangle data}

# make ID column rownames
rawCounts <- rawCounts %>% 
  column_to_rownames(var = "gene_id") #430 cases with RNAseq counts from GDC

#the gene names are already present within the rawCounts data 
annotated_genes <- data.frame(rawCounts$gene_name) 
annotated_genes <- data.frame(rownames(rawCounts), annotated_genes) # Create a new data frame with row names and the gene_name column
colnames(annotated_genes) <- c("ensembl_id", "gene_name") # Rename the columns for clarity

rawCounts <- rawCounts %>% 
  dplyr::select(-"gene_name")
#get list of IDs you need the metadata for (all those with RNAseq counts)
#note we have more than one sequencing file for some individuals eg TCGA-61-2008-01A.... and TCGA-61-2008-02A.... the 7-8th number in the sequence indicates the sample type, 01 is a primary tumour and 02 is a recurring tumour (see GDC sample type codes)
#filter to include only primary tumours
primary_samples <- as.data.frame(colnames(rawCounts)) %>% 
   str_trunc(16, "right", ellipsis = "") %>% 
  clean_names() %>% 
  dplyr::rename(submitter_id = colnames_raw_counts) %>% 
  filter(!str_detect(submitter_id,"02A") & !str_detect(submitter_id,"01R")) %>% # TCGA-23-1023 is present twice as TCGA-23-1023-01A and TCGA-23-1023-01R, I have removed 01R for now
  str_trunc(12, "right", ellipsis = "") 
  
rawCounts <- rawCounts %>% 
  dplyr::select(-matches("02A|TCGA-23-1023-01R")) # remove any secondary samples and TCGA-23-1023-01R

#filtered_pancan <- left_join(primary_samples, pancan_contrasts) 

# pull out cases not present in the pancancer table
#cases_missing_labels <- filtered_pancan %>% 
 # filter(is.na(cx3)) %>% 
 # dplyr::select(submitter_id) %>% 
 # write_delim("./Data/Processed/20230815_rnaseq_cases_missing_from_pancan.tsv", delim = "\t")

```

```{r, message=FALSE}
#reload the cases_missing_labels list annotated using Wang 2017 and Takaya 2020 annotation
cases_missing_labels <- read_csv("Data/Processed/20230815_rnaseq_cases_missing_from_pancan.csv")

pancan_contrasts_shortened <- pancan_contrasts %>% 
  dplyr::select("submitter_id", "contrast_group") #only need the contrast info for now
 
meta_plus_contrast <- cases_missing_labels %>% 
  dplyr::select("submitter_id", "contrast_group") %>% 
  full_join(meta)

# add in the contrast group info from cases_missing_labels into meta_plus_contrast group

meta_plus_contrast <- meta_plus_contrast %>%  
  left_join(pancan_contrasts_shortened, by = ("submitter_id")) %>%  
  mutate(contrast_group = if_else(is.na(contrast_group.y), contrast_group.x, contrast_group.y)) %>% 
  dplyr::select(-contrast_group.x, -contrast_group.y) 
#mutate line: the left_join merges the two tables by ID but keeps both contrast columns (renamed as contrast_group.y and contrast_group.x). The mutate creates a new column contrast_group, checks for NA in the contrast_group.y column and enters the value of the contrast_group.x column in the new contrast_group column if it is NA, otherwise it enters the value in the conrast_group.y column. 

#note if using if_else() from dplyr, use | and & as comparison operators, but if using if and else from base r, use || and && as comparison operators

 tabyl(meta_plus_contrast$contrast_group)
```
**matching primary samples in rawcounts to samples in meta data**
```{r}
meta_rawCounts_matched <- meta_plus_contrast[meta_plus_contrast$submitter_id %in% primary_samples$submitter_id,]

merged_data <- primary_samples %>%
  left_join(meta_rawCounts_matched, by = c("submitter_id" = "submitter_id"))

# Arrange the rows based on the order of submitter_id in primary_samples
meta_rawCounts_matched <- merged_data %>%
  arrange(match(submitter_id, primary_samples$submitter_id)) # Now ordered_data contains the rows from meta_rawCounts_matched in the same order as in primary_samples

colnames(rawCounts) <- substr(colnames(rawCounts), 1, 12)
```


**Create a DGE object for DE analysis.**
#NOTE need to delete the first DGEList object and run the two below if I am creating two separate DGEList objects for each contrast
```{r dgeObject}

dge <- DGEList(counts = rawCounts, genes = annotated_genes$ensembl_id, samples = meta_rawCounts_matched, group = meta_rawCounts_matched$contrast_group) # contains all samples in one object 

```


**Filter lowly expressed genes.**
*Using manual filtering and the filterByExp() function*

```{r }
# filter lowly expressed genes
cutoff <- 4
drop <- which(apply(cpm(dge), 1, max) < cutoff) #cpm() calculates counts per million for normalisation, apply() is then used to calculate the max (using max()) CPM value across all rows (1 means all rows, 2 would mean all columns), and which() returns indices of genes where max cpm < 4
dgeFil <- dge[-drop, , keep.lib.sizes = FALSE] 
dim(dgeFil) # number of genes left after manual filtering

keep <- filterByExpr(dgeFil, group = dgeFil$samples$contrast_group) 

dgeFilExp <- dgeFil[keep, ,keep.lib.sizes = FALSE ] 
dim(dgeFilExp) # number of genes left after manual filtering and filterByExpr

```

**just set up the analysis for contrast 1 for now, repeat on two after **
```{r}
#check for samples that have more counts on average than other samples 
boxplot(log(dgeFilExp$counts + 0.5), xaxt = "n", col = "turquoise4", xlab = "Samples") # look at raw log counts (+0.5 to prevent taking the log of 0)
boxplot(cpm(dgeFilExp$counts, log = TRUE), xaxt = "n", col = "turquoise4", xlab = "Samples") # look at log cpm normalised counts

plotSparsity(dgeFilExp$counts, normalized = TRUE) # normalised to account for variations in library size  to avoid sequencing bias


```

**Normalisation.**

```{r}

# calculate normalisation factors (does not normalise)
dgeFilExpNorm <- calcNormFactors(dgeFilExp)

barplot(dgeFilExpNorm$samples$norm.factors, las = 2)
title("Barplot of normalisation factors")

```

**Define group for contrast interactions**
```{r}

 
groupCol <-  interaction(dgeFilExpNorm$samples$contrast_group)
groupCol <- group # you could just use the original interaction vector, but I like to make a new one that I will overlay colours on.
levels(groupCol) <- c("#F8766D", "#00BFC4", "#00BA38") # change levels to colour names/HEX codes.
# BRCA1/2 Loss == turquoise (#00BFC4)
#HRD high == tomato ("#F8766D")
#HRD low == green ("#00BA38")
groupCol <- as.character(groupCol) # make sure R knows the colour replacements are characters.

plotMDS(dgeFilExpNorm, col = groupCol, labels = NULL, pch = 20) +
legend("topright", legend = c("BRCA1/2 loss", "HRD high", "HRD low"), fill =  c("#F8766D", "#00BFC4", "#00BA38"))
#distances on the plot approximate the typical log2 fold changes between the samples 

```
**defining covariate interactions**
#NOTE NEED to collapse the stages into 1-4, the separation may be too granular to see any possible confounders at present 
```{r}

stage <- interaction(dgeFilExpNorm$samples$figo_stage)
# Levels: Stage IC, IIA, IIB, IIC, IIIA, IIIB, IIIC, IV
levels(stage) <- c("darkorange", "cornflowerblue", "darkolivegreen3", "deeppink3", "darkorchid", "brown1", "darkgrey", "chartreuse" ) 
stage <- as.character(stage) 

plotMDS(dgeFilExpNorm, col = stage, labels = NULL, pch = 20)
legend("topright", legend = c("Stage IC", "IIA", "IIB", "IIC", "IIIA", "IIIB", "IIIC", "IV"), fill =  c("darkorange", "cornflowerblue", "darkolivegreen3", "deeppink3", "darkorchid", "brown1", "darkgrey", "chartreuse" ) )


```
```{r}

age_at_diagnosis <- interaction(dgeFilExpNorm$samples$age_at_diagnosis)

plotMDS(dgeFilExpNorm, col = age_at_diagnosis, labels = NULL, pch = 20)

```
```{r}

site <- interaction(dgeFilExpNorm$samples$site_of_resection_or_biopsy)

plotMDS(dgeFilExpNorm, col = site, labels = NULL, pch = 20)

```
These MDS plots are *extremely* important. They show what most of your variation comes from. These covariates need to be included in our design matrix, since we are primarily interested in BRCA1/2 and HRD status.


**Define the design matrix.**

```{r}

# specify the model to be fitted
modelMatrix <- model.matrix(~ 0 + group )
# currently not adjusting for any additional covariates
```

**Voom transformation.** 

```{r}

# voom transformation
voomUnTrAn <- voom(dgeUnTreAnFilExpNorm, modelMatrixAn, plot = TRUE) 

# look at diagnostic plots
plotMDS(dgeUnTreAnFilExpNorm, col = groupCol, labels = NULL, pch = 20)
legend("topright", legend = c("auranofin", "untreated"), fill =  c("#F8766D", "#00BFC4"))

```

**redundant**
**steps which were required before running DGEList**

**Annotate genes - not necessary if using gene_names present in rawCounts data.**

```{r geneAnnotation}
 # Human Ensembl/GENCODE gene accession numbers start with ENSG followed by a number and version number separated by a dot. 
ensembl <- data.frame(ensembl_id = rownames(rawCounts)) %>%  #create a data frame with a column for row names
  separate(ensembl_id, into = c("ensembl_id", "version_number"), sep="\\.")  #escape the dot in sep argument using \\. because the dot is a special character

ensembl_id <- as.character(ensembl$ensembl_id) # don't need version number for now, keys must be provided as character 


colGene <- c("ENTREZID", "SYMBOL", "GENETYPE", "ENSEMBL") #defines the columns you want to select from the gene annotation database

geneIdMap <- AnnotationDbi::select(org.Hs.eg.db, #the org.Hs.eg.db package provides annotations for the human genome
                                       keys = ensembl_id, 
                                       columns = colGene, keytype = "ENSEMBL") #queries the org.Hs.eg.db gene annotation database using the Ensembl Gene IDs as keys. It retrieves the specified columns (colGene) for the provided gene IDs (gene_id) using the specified key type (ENSEMBL).

count(is.na(geneIdMap$ENTREZID)) # 24622 don't match to an ID
duplicated_geneIdMap <- geneIdMap %>% 
  filter(duplicated(ENTREZID) &!is.na(ENTREZID)) #2812 duplicated ID

#remove duplicated rows from the geneIdMapExAn data frame based on the ENTREZID column (retaining one copy of any duplicated name)
geneIdMap <- geneIdMap[!duplicated(geneIdMap$ENTREZID), ]

geneIdMap <- geneIdMap[geneIdMap$ENSEMBL %in% ensembl_id, ] 
geneIdMap <- geneIdMap[complete.cases(geneIdMap), ] # one gene has missing entries, remove

genes <-  geneIdMap$ENSEMBL

#(question for Ash, is it normal to go from 60660 to 36639 rows of gene expression data after gene annotation?)

```


**Create matrix of read counts.**

```{r}

rawCountsCleaned <- as.matrix(rawCounts[genes, ]) %>% # filters the raw count data for genes that match the annotated expression data and converts to a matrix 
  apply( 2, function(x) as.numeric(trimws(x))) 
rownames(rawCountsCleaned) <- rownames(rawCounts[genes, ])

#apply(...) applies the function that removes leading spaces and converts values to numeric for each column of the filtered and converted matrix....
   #apply is used to apply a function to each column (indicated by '2')
   #the function is an anonymous function created using function(x) - Inside the function: trimws(x): removes leading and trailing white spaces from the character values in column x which are then converted to numbers.
count(is.na(meta_rawCounts_matched$contrast_group)) #DGEList can't accept NA values

 meta_rawCounts_matched <- meta_rawCounts_matched %>% 
  mutate(contrast_group = if_else(is.na(contrast_group), "unknown", contrast_group)) #if NA in contrast_group, replace with "unknown", otherwise keep contrast_group entry


dge <- DGEList(counts = rawCountsCleaned, genes = geneIdMap_clean$ENTREZID, samples = meta_rawCounts_matched, group = meta_rawCounts_matched$contrast_group) 

```

