---
title: "20231204_DGE"
output: html_document
date: "2023-12-04"
---


```{r, setup, include=FALSE}
library(AnnotationHub)
library(ensembldb)
library(AnnotationDbi) # install from CRAN
library(clusterProfiler)
library(msigdbr)
library(pathview)
library(pheatmap) #only require if I use alternatie heatmap method, otherwise need "ComplexHeatmap"
library(org.Hs.eg.db) #install from CRAN
library(limma) #install from CRAN
library(edgeR)
library(DESeq2)
library(janitor)
library(statmod)
library(GO.db)
library(tidyverse) 


projDir = "/run/user/1804238067/gvfs/sftp:host=clust1-headnode,user=lythgo02/mnt/nas1-data/jblab/group_folders/emily_lythgoe/20230724_EcoTyper_2nd_year"
knitr::opts_knit$set(root.dir = projDir) #sets location for output files to projDir 
knitr::opts_chunk$set(echo = TRUE) #setting default option for all code chunks 
```

# Differential Gene Expression Analysis on TCGA Ovarian Cohort
##BRCA1/2 loss vs non-BRCA1/2 HRD high vs HRD low (assumed HR proficient)

###Requires output from 20231204_datawrangling_DGE.Rmd


Because I will filter out genes with low expression before DGE, makes sense
to filter the genes before annotation.This should reduce the number of genes 
with duplicate IDs allowing me to manually check any duplicates and select 
which to keep. 

##Filter genes by expression

```{r}
rawCounts_filtered <- as.matrix(rawCounts_final[,-1]) # remove gene_name col
cpmCounts <- cpm(rawCounts_filtered)
#cpm() calculates counts per million for normalisation

keepGenesCPM <- rowMax(cpmCounts) >= 4
#logical vector of genes to keep based on expression levels

filCounts <- rawCounts_filtered[keepGenesCPM,] # 22250 genes remain
keepGenesExpr <- filterByExpr(filCounts, 
                              group = meta_rawCounts_matched$contrast_group)
genesToKeep <- names(keepGenesExpr)[keepGenesExpr]
length(genesToKeep)
# [1] 20981
```

We may still filter out more genes due to annotation issues, but for now this
is all the genes we might end up using.

##Generate an annotation

```{r geneAnnotation}
colGene <- c("ENTREZID", "SYMBOL", "GENETYPE", "ENSEMBL") 

#query org.Hs.eg.db gene annotation database using the Ensembl Gene IDs as keys, 
#retrieving  the specified columns (colGene)
geneIdMap <- AnnotationDbi::select(org.Hs.eg.db, 
                                  keys = genesToKeep,
                                  columns = colGene, 
                                  keytype = "ENSEMBL") 

sum(is.na(geneIdMap$ENTREZID))
# [1] 2787

dupEntrez <- geneIdMap %>% 
  filter(!is.na(ENTREZID)) %>%
  filter(n() > 1, .by = ENTREZID)
#filter missing and non-unique rows by ENTREZID

length(unique(dupEntrez$ENTREZID))
# [1] 33

```

33 = small enough number to manually check via Ensembl and try to decide 
which is the most appropriate. Can also check expression levels:

```{r, check expression for duplicates}

SPATA13 <- dupEntrez %>% filter(ENTREZID==221178) %>% pull(ENSEMBL)

#density plot of logCPM for each ENSEMBL ID of SPATA13
 cpmCounts[rownames(cpmCounts)%in%SPATA13,] %>%
    as.data.frame() %>%
    rownames_to_column("GeneID") %>%
    pivot_longer(names_to = "Sample", values_to = "CPM", -GeneID) %>%
    mutate(logCPM = log2(CPM + 0.1)) %>%
    ggplot(aes(x = logCPM)) +
        geom_density(aes(colour = GeneID))
```
given that these are overlapping loci (see Ensembl) I'd select the gene with 
the higher expression - ENSG00000182957 


Or for RABL2A we have 

```{r}
dupEntrez %>% filter(SYMBOL=="RABL2A")    
```
But Emsembl says that ENSG00000079974 should be RABL2B, which is ENTREZ 11158:
https://www.ncbi.nlm.nih.gov/gene/11158

In this case we have a duplicated Ensembl ID:

```{r}
filter(geneIdMap, ENTREZID==11159
)
filter(geneIdMap, ENSEMBL=="ENSG00000079974") 
```

So we need to delete the entry that is 
        ENSEMBL ENTREZID SYMBOL       GENETYPE
ENSG00000079974    11159 RABL2A protein-coding


I went through the dupEntrez list and checked each ID. Most were incorrectly 
labelled, some had multiple ID for the same locus in which case I checked which 
had the higher count value. For RNVU1-29 and RNVU1-18 I picked at random due to 
lack of info. This left me with the genes in Entreztokeep.csv
```{r}
#remove from geneIdMap
EntrezToKeep <- read_csv("./Entreztokeep.csv") %>% 
  select(-"Actual ENSEMBL match",-"Annotation",-"Density plot readout") %>% 
  as.data.frame() 
EntrezToKeep$ENTREZID <- as.character(EntrezToKeep$ENTREZID)

#create a df of the genes to remove from the larger geneIDmap  
EntrezToDiscard <- anti_join(dupEntrez,EntrezToKeep, by= c("ENSEMBL","ENTREZID"))

#remove from geneIdMap
geneIdMapFil <- anti_join(geneIdMap,EntrezToDiscard, by= c("ENSEMBL","ENTREZID"))


```


```{r}
dupEnsembl <- geneIdMapFil %>% 
  filter(!is.na(ENTREZID)) %>%
  filter(n() > 1, .by = ENSEMBL)
length(unique(dupEnsembl$ENSEMBL))
# [1] 145 after filtering out duplicated ENTREZID
```

Keep the first of each duplicated ENSEMBL ID.

```{r}
#keep the first instance of each duplicated ENSEMBL ID
geneIdMapFil <- geneIdMapFil %>% 
        distinct(ENSEMBL, .keep_all=TRUE)

  
sum(duplicated(geneIdMapFil$ENSEMBL))
# [1] 0
# There's no remaining duplicated ENSEMBL ids.

```
Dont throw out ones with missing Entrez ID as this doesn't matter for GSEA, 
just use the ENSEMBL ID and then you will have the same gene list for the GSEA 
as you do for the DGE.

##Alternate method of mapping using AnnotationHub

May be a more suitable approach as AnnotationHub only returns 18 duplicates 
(after filtering out low expression genes) and won't annotate pseudo/ncRNA etc 
if there is a protein coding version available.


```{r usingAnnotationHub}
# Create an AnnotationHub object for Homo sapiens
ah <- AnnotationHub()

# Create a query to retrieve gene annotation data from AnnotationHub
humanEnsDb <- query(ah, c("EnsDb", "Homo sapiens", "109"))[[1]]
annotations <- genes(humanEnsDb, return.type = "data.frame")

annot <- annotations %>%
   select(gene_id, gene_name, entrezid) %>%
   filter(gene_id %in% genesToKeep)

length(unique(annot$gene_id)) 

sum(is.na(annot$entrezid)) 

annot %>%
    filter(!is.na(entrezid)) %>%
    filter(n() > 1, .by = entrezid)
```

There are only a few duplicated ENTREZ ids, so this would be easy to sort out.
Also, the ones that we are missing here but get using the org.Hs.eg.db method
are not that interesting:

```{r}
annot %>%
    dplyr::filter(is.na(entrezid)) %>%
    inner_join(geneIdMapFil, by = c(gene_id = "ENSEMBL")) %>%
    as_tibble() %>%
    count(GENETYPE)
```

I will continue with the annotation generated by the org.Hs.eg.db methods for
now.

```{r prepare_dge_list_object}
counts <- rawCounts_final[geneIdMapFil$ENSEMBL,] %>%
    select(-gene_name) %>%
    as.matrix()

dge <- DGEList(counts = counts, 
                 genes = geneIdMapFil, 
                 samples = meta_rawCounts_matched, 
                 group = meta_rawCounts_matched$contrast_group) 
```


# Process all contrast groups together

```{r, visualise count distribution}

#check for samples that have more counts on average than other samples 
boxplot(log(dge$counts + 0.5), 
        xaxt = "n", 
        col = "turquoise4", 
        xlab = "Samples") 
boxplot(cpm(dge$counts, log = TRUE), 
        xaxt = "n", 
        col = "turquoise4", 
        xlab = "Samples")

plotSparsity(dge$counts, normalized = TRUE) 
# normalised to account for variations in library size to avoid sequencing bias
```


**Normalisation**

```{r}
# calculate normalisation factors (does not normalise)
dgeNorm <- calcNormFactors(dge)

hist(dgeNorm$samples$norm.factors)

#or with ggplot
# Extract normalization factors from the DESeqDataSet object
norm_factors <- dgeNorm$samples$norm.factors

# Create a histogram using ggplot2
ggplot(data.frame(NormFactors = norm_factors), aes(x = NormFactors)) +
  geom_histogram(binwidth = 0.05, fill = "blue", color = "black", alpha = 0.7) +
  labs(title = "Distribution of Normalization Factors",
       x = "Normalization Factors",
       y = "Frequency") +
  theme_minimal()
```

##Check for interactions 

## MDS plots {.tabset}
Multidimensional scaling plot of distances between gene expression profiles
This function uses MDS to produce a principal coordinate (PCoA) or principal
component (PCA) plot showing the relationships between samples. Distance 
between spots (samples) on plot represent log2 fold changes between samples. 
Use to identify interacting variables that you may want to control for in DE.



```{r getMDSdata, include = FALSE}
mdsDat <- plotMDS(dgeNorm, plot = FALSE)
#only need to run plotMDS once for all factors you want to plot (all contained within mdsDat object)

plotDat <- as_tibble(dgeNorm$samples) %>%
    mutate(X = mdsDat$x) %>%
    mutate(Y = mdsDat$y)

plotDat
```

## Contrast Group

```{r}
ggplot(plotDat, aes(x = X, y = Y)) +
        geom_point(aes(colour = contrast_group)) +
  labs(title = "Contrast Group")
```

## Stage

```{r}
ggplot(plotDat, aes(x = X, y = Y)) +
        geom_point(aes(colour = figo_stage))
```

## Ecotype

```{r}
ggplot(plotDat, aes(x = X, y = Y)) +
        geom_point(aes(colour = carcinoma_ecotype))
```
Some separation of ecotypes but not correcting for this as it is confounded
with gene expression (used to generate the CE classification) and the contrasts 
## Site

```{r}
ggplot(plotDat, aes(x = X, y = Y)) +
        geom_point(aes(colour = site_of_resection_or_biopsy))
```

**Define design matrix**

```{r}

modelMatrix <- model.matrix(~ 0 + contrast_group, data=dgeNorm$samples)
colnames(modelMatrix) <- str_remove(colnames(modelMatrix), "contrast_")
```

**Voom transformation** 

```{r}
voom <- voom(dgeNorm, modelMatrix, plot = TRUE) 
# transforms counts to log2 CPM based on the normalisation factors calculated
# earlier & fits a linear model to the log2 CPM for each gene (row-wise),
# calculates the residuals, and fits a smoothed curve to the square root of the
# residual standard deviation by average expression. The smoothed curve is used
# to obtain weights for each gene and sample, which are then passed into limma
# for DE, taking into account the variability of each gene.
```


**Fit linear model**

```{r}
# fitting a linear model using weighted least squares for each gene
fit <- lmFit(voom, modelMatrix) # now run DEA
head(coef(fit)) 
#display coefficients used for hypothesis testing of sig. up/down regulated genes 

```

**Define contrast**

BRCA1/2 loss is the baseline for each contrast

```{r}
# comparison between groups using the fitted linear model gives log-fold changes
contr <- makeContrasts(groupHRD_high - groupBRCA1_2_loss, 
                       groupHRD_low - groupBRCA1_2_loss, 
                       levels = modelMatrix) 
#  groupHRD_high - groupBRCA1_2_loss, # Coefficient 1
 # groupHRD_low - groupBRCA1_2_loss,  # Coefficient 2
contr
#-1 = reference
#0 = not included in comparison
#1 = group to compare against reference

contrastsfit <- contrasts.fit(fit, contrasts = contr) 
# fit contrasts to model & calculate coefficients 

fittedContrasts <- eBayes(contrastsfit, robust = TRUE) 

```
###eBayes() Robust emperical bayes for statistical testing to account for heteroscedasticy 
in the data. Helps to obtain more accurate p-values and effect size estimates.

**Extract to contrasts and statistical testing**
The output from topTable() includes:
-logFC: the log fold-change between cases and controls
-t: the t-statistic for DE
-P.Value: for DE (not adjusted for multiple testing)
-adj.P.Val: p-value adjusted for multiple testing. 
 Default adjustment method = Benjamini-Horchberg

```{r}
results_HRDhigh <- topTable(fittedContrasts, 
                            coef= "groupHRD_high - groupBRCA1_2_loss", 
                            sort.by = "P", n = Inf) 
head(results_HRDhigh, 20) # look at top 20 DE genes (sorted by p value), n=Inf means retreive all DE genes (no limit on number)

up_genes_BRCAloss_HRDhigh <- results_HRDhigh %>%
  dplyr::filter(adj.P.Val < 0.05, logFC >= 1.0) %>% 
  write_csv("Output/Data/20231211_up_genes_BRCAloss_HRDhigh.csv")
  
down_genes_BRCAloss_HRDhigh <- results_HRDhigh %>%
  dplyr::filter(adj.P.Val < 0.05, logFC <= -1.0) %>% 
  write_csv("Output/Data/20231211_down_genes_BRCAloss_HRDhigh.csv")
  
allDEgenes_BRCAloss_HRDhigh <- results_HRDhigh %>%
  dplyr::filter(adj.P.Val < 0.05, abs(logFC) >= 1.0) %>% 
  write_csv("Output/Data/20231211_DEgenes_BRCAloss_HRDhigh.csv")

results_HRDlow <- topTable(fittedContrasts, coef= "groupHRD_low - groupBRCA1_2_loss", sort.by = "P", n = Inf)
head(results_HRDlow, 20)

up_genes_BRCAloss_HRDlow <- results_HRDlow %>%
  dplyr::filter(adj.P.Val < 0.05, logFC >= 1.0) %>% 
   write_csv("Output/Data/20231211_up_genes_BRCAloss_HRDlow.csv") 

down_genes_BRCAloss_HRDlow <- results_HRDlow %>%
  dplyr::filter(adj.P.Val < 0.05, logFC <= -1.0) %>% 
  write_csv("Output/Data/20231211_down_genes_BRCAloss_HRDlow.csv")
  
allDEgenes_BRCAloss_HRDlow <- results_HRDlow %>%
  dplyr::filter(adj.P.Val < 0.05, abs(logFC) >= 1.0) %>% 
  write_csv("Output/Data/20231211_DEgenes_BRCAloss_HRDlow.csv")
```

**Venn Diagram**
```{r}
  venn_list <- list(
      up_in_HRD = as.character(up_genes_BRCAloss_HRDhigh$SYMBOL),
      up_in_HRP = as.character(up_genes_BRCAloss_HRDlow$SYMBOL),
      down_in_HRD = as.character(down_genes_BRCAloss_HRDhigh$SYMBOL),
      down_in_HRP = as.character(down_genes_BRCAloss_HRDlow$SYMBOL))
  
 
vennDat <- ggvenn::ggvenn(venn_list, set_name_size = 3)   

vennDat + labs(title = "In comparison to BRCA1/2 loss")

```
As we would expect, lots more genes up/down regulated in the HR proficient group 
in comparison to the BRCA1/2-mediated HRD group than we see when we compare the 
non BRCA1/2-mediated HRD (suspected) group to the BRCA1/2-HRD group.

**Sanity checks**
```{r}
hist(results_HRDhigh$P.Value)

hist(results_HRDlow$P.Value)
```

**Just looking at BRCA1/2 vs HRD low**
```{r}

# Total number of DE genes based on adjusted p value < 0.05
length(which(results_HRDlow$adj.P.Val < 0.05))

# Total number of DE genes based on adjusted p value < 0.05 and |logFC| (absolute log fold-change) >= 1.0
length(which(results_HRDlow$adj.P.Val < 0.05 & abs(results_HRDlow$logFC) >= 1.0 ))

# Total number of DE genes based on adjusted p value < 0.01 and |logFC| >= 1.0
length(which(results_HRDlow$adj.P.Val < 0.01 & abs(results_HRDlow$logFC) >= 1.0 ))

dtTab <- decideTests(fittedContrasts, p.value = 0.05, lfc = 1.0) #makes DE gene calls based on a specified p-value and log-fold change threshold 
summary(dtTab)
```


**Plots for DE contrast: BRCA1/2 loss vs HRD low**

```{r}
#to plot a measure of significance against fold change 
volcanoplot(
  fittedContrasts,             
  coef = "groupHRD_low - groupBRCA1_2_loss", # Specify which contrast to visualize
  highlight = 10,               # The number of top genes to highlight 
  names = fittedContrasts$genes$SYMBOL,    
  main = "Volcano Plot"        # Plot title 
)

#x axis - upregulation (positive values) and downregulation (negative) of genes 
#y-axis - statistical significance 
#each gene = a dot

```

```{r MA plot with ggplot}
#MA plot displays log-fold change against the average log expression for each gene 
#build necessary data into dataframe for use with ggplot
#require adjusted p-value/FDR
#greppel = handy package to push labels around geom_text_repel
library(ggrepel)

MAplotlow <- results_HRDlow %>%  arrange(desc(adj.P.Val))
#arrange so we can label the top 10 
MAplot_HRDlow <- ggplot(MAplotlow, aes(x = AveExpr, y = logFC)) +
    geom_point(aes(colour = adj.P.Val < 0.05), size = 1) +
    geom_text_repel(data = ~top_n(.x, 10, wt = -adj.P.Val), #select top 10 genes for labeling by negative adj.p.value (i.e. the ten most sig)
                    aes(label = SYMBOL),
                    size=3.3,
                    min.segment.length = unit(0, 'lines'),
                    box.padding = 0.5) +
    labs(
        x = "Average Log-Expression",
        y = "Log-Fold Change",
        title = "MA Plot: HR Proficient vs BRCA1/2 Loss",
        color = "FDR < 0.05"
    ) + 
   theme_classic()


MAplothigh<- results_HRDhigh %>% arrange(desc(adj.P.Val))
MAplot_HRDhigh <- ggplot(MAplothigh, aes(x=AveExpr, y=logFC)) +
  geom_point(aes(colour = adj.P.Val < 0.05), size=1) + 
               geom_text_repel(data= ~top_n(.x, 10, wt=-adj.P.Val), 
                               aes(label=SYMBOL),
                               size=3.3,
                                min.segment.length = unit(0, 'lines'),
                                box.padding = 0.5) +
    labs(
        x = "Average Log-Expression",
        y = "Log-Fold Change",
        title = "MA Plot: Non-BRCA1/2 HRD vs BRCA1/2 Loss",
        color = "FDR < 0.05"
    ) +
  theme_classic()

MAplot_HRDlow
MAplot_HRDhigh
```
ENSG00000280303 = E2F1-regulated inhibitor of cell death lncRNA, missing 
annotation so filtered out from heatmap along with 27 others for the 
HRDlow comparison. All those missing annotation appear to be non-coding 
or novel genes.
```{r, include=FALSE, eval = FALSE}
library(ComplexHeatmap)
library(circlize)
# Select the top genes based on adj.P.Val
  topGenesHRDlow <- results_HRDlow %>% 
  top_n(300, wt= -adj.P.Val) %>% 
  pull(ENSEMBL)

  plotDat <- voom$E[topGenesHRDlow,]
  
  z.mat <- t(scale(t(plotDat), center=TRUE, scale=TRUE))

# colour palette
myPalette <- c("royalblue3", "ivory", "orangered3")
myRamp <- colorRamp2(c(-2, 0, 2), myPalette)

Heatmap(z.mat, name = "z-score",
        col = myRamp,
        show_row_names = FALSE, 
        show_column_names = FALSE)

topGenesHRDhigh <- results_HRDhigh %>% 
  top_n(300, wt= -adj.P.Val) %>% 
  pull(ENSEMBL)

  plotDath <- voom$E[topGenesHRDhigh,]
  
  z.math <- t(scale(t(plotDath), center=TRUE, scale=TRUE))

  Heatmap(z.math, name = "z-score",
        col = myRamp,
        show_row_names = FALSE, 
        show_column_names = FALSE)
  
```


**Gene ontology analysis with Goana**

```{r}
# subset DE genes to include those of great significance and large-ish logFC
genesDE_HRDhigh <- results_HRDhigh %>%
  mutate(bigLogFC = case_when(logFC < -1.0 | logFC > 1.0 ~ "keep",
                              TRUE ~ "discard")) %>% 
  dplyr::filter(bigLogFC == "keep") %>% 
  dplyr::filter(adj.P.Val < 0.05) %>% 
  dplyr::select(ENTREZID) 
genesDE_HRDhigh <- as.vector(genesDE_HRDhigh)  

## gene ontology
gene_ont <- goana(genesDE_HRDhigh)
 topGO(gene_ont)

gene_ont$adj.P.Val <- p.adjust(gene_ont$P.ENTREZID, method="BH")

gene_ont <- gene_ont %>% 
  rownames_to_column(var = "goTerm")

#write_csv(gene_ont, "Output/Data/TCGA_DGE_geneOntology_20230922.csv")

```

**Clusterprofiler (Yu et al. 2012)**

**Supports direct online access of the current KEGG database (KEGG: Kyoto Encyclopedia of Genes and Genomes), rather than relying on R annotation packages**

```{r, KEGG enrichment analysis}

search_kegg_organism('human', by='common_name') #kegg code = hsa

sigGenes_HRDhigh <- allDEgenes_BRCAloss_HRDhigh %>% 
   pull(ENTREZID) %>% 
  as.numeric()

sigGenes_HRDlow <- allDEgenes_BRCAloss_HRDlow %>% 
   pull(ENTREZID) %>% 
  as.numeric()

 keggResHigh <- enrichKEGG(gene= sigGenes_HRDhigh, organism = 'hsa')
 
 keggReslow <- enrichKEGG(gene= sigGenes_HRDlow, organism = 'hsa')
 
 as_tibble(keggReslow)
 browseKEGG(keggResHigh, 'hsa04657') # to visualise one of the hits in browser
 
``` 

Wont map IDs using correct EntrezIDs eg BRCA1 hsa672

```{r}
ewe <- enrichKEGG(gene= sigGenes_HRDlow, 
                   organism = 'hsa',
                   pvalueCutoff = 1,
                   qvalueCutoff = 1)
filter(as.data.frame(ewe), str_detect(geneID, "672"))
```


```{r}
logFC_HRDlow <- results_HRDlow%>% dplyr::select(ENTREZID, logFC) 
rownames(logFC_HRDlow) <- logFC_HRDlow$ENTREZID


logFC_HRDlow <- logFC_HRDlow %>% dplyr::select(logFC) 

pathview(gene.data = logFC_HRDlow, 
         pathway.id = "04657", 
         species = "hsa", 
         kegg.native = TRUE, # switch to false for PDF 
         multi.state = TRUE,
         out.suffix = "BRCAvsHRDlow_IL17",
         keys.align = "y",
         bins = 15,
        low=list(gene="steelblue"),
        high=list(gene="gold"),
        limit = list(gene=3, cpd=1)) # specifies the limit values for gene.data and cpd.data when converting them to pseudo colors

pathview(gene.data = logFC_HRDlow, 
         pathway.id = "hsa04080", 
         species = "hsa", 
         kegg.native = TRUE,   # switch to false for PDF
         multi.state = TRUE,
         out.suffix = "BRCAvsHRDlow",
         keys.align = "y",
         #limit = 3, # specify range of colour scale 
         bins = 15,
        low=list(gene="steelblue"),
        high=list(gene="gold"),
        limit = list(gene=3, cpd=1)) # specifies the limit values for gene.data and cpd.data when converting them to pseudo colors

pathview(gene.data = logFC_HRDlow, 
         pathway.id = "hsa672", 
         species = "hsa", 
         kegg.native = TRUE,   # switch to false for PDF
         multi.state = TRUE,
         out.suffix = "BRCAvsHRDlowBRCA1",
         keys.align = "y",
         #limit = 3, # specify range of colour scale 
         bins = 15,
        low=list(gene="steelblue"),
        high=list(gene="gold"),
        limit = list(gene=3, cpd=1)) # specifies the limit values for gene.data and cpd.data when converting them to pseudo colors
```

**clusterProfiler can also perform over-representation analysis on GO terms with enrichGO**

can't generate a plot for the BRCA1 vs HRDhigh

```{r}

sigGenes_HRDlow <- allDEgenes_BRCAloss_HRDlow %>% 
   pull(ENSEMBL) 
universe <- results_HRDlow$ENSEMBL # create a background (universe) gene list = all genes in analysis 

ego <- enrichGO(gene          = sigGenes_HRDlow, # defined earlier 
                universe      = universe,
                OrgDb         = org.Hs.eg.db,
                keyType       = "ENSEMBL",
                ont           = "ALL", # One of "BP" (biological processes), "MF", and "CC" subontologies, or "ALL" for all three.
                pvalueCutoff  = 0.01,
                readable      = TRUE)

dotplotHRDlow <- dotplot(ego, font.size = 9)
print(dotplotHRDlow)

sigGenes_HRDhigh <- allDEgenes_BRCAloss_HRDhigh %>% 
   pull(ENSEMBL) 
universe <- results_HRDhigh$ENSEMBL # create a background (universe) gene list = all genes in analysis 

ego <- enrichGO(gene          = sigGenes_HRDhigh, # defined earlier 
                universe      = universe,
                OrgDb         = org.Hs.eg.db,
                keyType       = "ENSEMBL",
                ont           = "ALL",
                pvalueCutoff  = 0.01,
                readable      = TRUE)

dotplotHRDhigh <- dotplot(ego, font.size = 9) 
print(dotplotHRDhigh)

```
**GSEA**
```{r}

# Load pathway details
term2gene <- msigdbr(species = "Homo sapiens", category = "H") %>%
  select(gs_name, entrez_gene)

term2name<- msigdbr(species = "Homo sapiens", category = "H") %>%
  select(gs_name, gs_description) %>%
  distinct()

# rank genes (by combining the sign of the fold change and the pvalue)
rankedGenesHRDlow <- results_HRDlow %>%
  mutate(rank = -log10(P.Value) * sign(logFC)) %>%
  arrange(desc(rank)) %>%
  pull(rank, ENTREZID)

gseaRes.HRDlow <- GSEA(rankedGenesHRDlow,
                TERM2GENE = term2gene,
                TERM2NAME = term2name,
                pvalueCutoff = 1.00, 
                minGSSize = 15,
                maxGSSize = 500)
```

